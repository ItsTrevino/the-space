<!doctype html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D-rummet – extruderad vägg + nisch + himmel</title>
  <style>
    html,body{height:100%;margin:0;background:#111}
    canvas{display:block;width:100vw;height:100vh}
  </style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script>
/* ======= Mått (meter) ======= */
const W=4.0, D=4.1, H=3.0;          // rum
const VAGG_TJ = 0.30;               // väggtjocklek (synlig kant)
const F_BREDD = 1.5;                // fönsterbredd
const F_HOJD  = 2.35;               // fönsterhöjd (välvt upptill)
const F_SILL  = 0.65;               // höjd till underkant
const F_SMYG  = 0.40;               // nischdjup (UTÅT)
const OFF_Z   = 1.0;                // avstånd från väggens mitt till resp. fönstercentrum (längs Z)

/* ======= Scen och renderer ======= */
const scene=new THREE.Scene();
scene.background=new THREE.Color(0xdddddd);

const camera=new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.05, 100);
const lookTarget=new THREE.Vector3(0,1.5,-1.5);
camera.position.set(0,1.5,1.8);
camera.lookAt(lookTarget);

const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setPixelRatio(Math.min(2, devicePixelRatio||1));
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

/* ======= Ljus ======= */
scene.add(new THREE.HemisphereLight(0xffffff,0x666666,1.15));
const dir=new THREE.DirectionalLight(0xffffff,0.9);
dir.position.set(4,6,3);
scene.add(dir);

/* ======= Material ======= */
const matWall = new THREE.MeshStandardMaterial({color:0xffffff, roughness:0.94, side:THREE.BackSide});
const matFloor= new THREE.MeshStandardMaterial({color:0x111111, roughness:1.0});
const matCeil = new THREE.MeshStandardMaterial({color:0xffffff, roughness:0.94});

/* ======= Golv, tak, bak- och vänstervägg ======= */
const floor=new THREE.Mesh(new THREE.PlaneGeometry(W,D),matFloor);
floor.rotation.x=-Math.PI/2; floor.position.set(0,0,-D/2); scene.add(floor);

const ceil =new THREE.Mesh(new THREE.PlaneGeometry(W,D),matCeil);
ceil.rotation.x = Math.PI/2; ceil.position.set(0,H,-D/2); scene.add(ceil);

const back =new THREE.Mesh(new THREE.PlaneGeometry(W,H),matWall);
back.position.set(0,H/2,-D); scene.add(back);

const leftW=new THREE.Mesh(new THREE.PlaneGeometry(D,H),matWall);
leftW.rotation.y= Math.PI/2; leftW.position.set(-W/2,H/2,-D/2); scene.add(leftW);

/* ======= Högervägg: RIKTIGA hål + nisch utåt ======= */
// 1) Väggshape i 2D (bredd=D, höjd=H)
const wallShape = new THREE.Shape();
wallShape.moveTo(-D/2,0); wallShape.lineTo(D/2,0); wallShape.lineTo(D/2,H);
wallShape.lineTo(-D/2,H); wallShape.closePath();

// 2) Två välvda fönsterhål (rätt orienterade)
// ---------- HÅL: korrekt uppåt välvt fönster ----------
function archedPath(cx, bottomY, width, height) {
  const r = width/2;
  const straightH = height - r;
  const yTop = bottomY + straightH;

  const p = new THREE.Path();
  // börja nere vänster, medurs runt öppningen
  p.moveTo(cx - width/2, bottomY);     // botten vänster
  p.lineTo(cx + width/2, bottomY);     // botten höger
  p.lineTo(cx + width/2, yTop);        // upp höger sida
  // NYCKELN: rita toppen från PI -> 0 (medurs) så “kupolen” öppnar uppåt
  p.absarc(cx, yTop, r, Math.PI, 0, true);
  p.lineTo(cx - width/2, yTop);        // ned vänster sida
  p.closePath();
  return p;
}

// lägg in hålen (samma Z-centra som tidigare)
const z1 = -OFF_Z, z2 = +OFF_Z;
wallShape.holes.length = 0; // töm ev. gamla
wallShape.holes.push(archedPath(z1, F_SILL, F_BREDD, F_HOJD));
wallShape.holes.push(archedPath(z2, F_SILL, F_BREDD, F_HOJD));

// 3) Extrudera VÄGG (tjocklek in i X-riktning)
const wallGeom = new THREE.ExtrudeGeometry(wallShape, { depth: VAGG_TJ, bevelEnabled:false, curveSegments:64 });
// geometri-axlar → rotera så att extruderingen pekar ut ur rummet ( +X )
wallGeom.rotateY(-Math.PI/2);
// lägg insidan av vägg i x = W/2 - VAGG_TJ
wallGeom.translate(W/2 - VAGG_TJ, 0, -D/2);
const rightWall = new THREE.Mesh(wallGeom, new THREE.MeshStandardMaterial({color:0xffffff, roughness:0.94}));
scene.add(rightWall);

// 4) NISCH (reveal) – extrudera ytterligare F_SMYG utåt
const revealGeom = new THREE.ExtrudeGeometry(wallShape, { depth: F_SMYG, bevelEnabled:false, curveSegments:64 });
revealGeom.rotateY(-Math.PI/2);
revealGeom.translate(W/2, 0, -D/2); // börjar direkt från väggens utsida
const reveal = new THREE.Mesh(revealGeom, new THREE.MeshStandardMaterial({color:0xf3f3f3, roughness:0.96}));
scene.add(reveal);

// 5) GLAS – välvd skiva längst ut i nischen (x = W/2 + F_SMYG)
function archedShape(width, height){
  const r=width/2, straightH=height-r, s=new THREE.Shape();
  s.moveTo(-width/2,0); s.lineTo(width/2,0); s.lineTo(width/2,straightH);
  s.absarc(0, straightH, r, 0, Math.PI, true); s.lineTo(-width/2,straightH); s.closePath();
  return s;
}
const glassMat=new THREE.MeshPhysicalMaterial({color:0xffffff, roughness:0.05, metalness:0, transmission:0.9, thickness:0.02, transparent:true});
[z1,z2].forEach(cz=>{
  const g=new THREE.ShapeGeometry(archedShape(F_BREDD,F_HOJD), 64);
  g.translate(0, F_SILL, 0);                           // sätt underkant på F_SILL
  const m=new THREE.Mesh(g, glassMat);
  m.position.set(W/2 + F_SMYG + 0.005, 0, cz);         // längst ut i nischen
  m.rotation.y = -Math.PI/2;
  scene.add(m);
});

// 6) “Gata” – stor plan yta en bit bakom glaset, centrerad mellan fönstren
const streetURL='https://images.unsplash.com/photo-1505764706515-aa95265c5abc?q=80&w=1600&auto=format&fit=crop';
new THREE.TextureLoader().load(streetURL, tex=>{
  tex.colorSpace=THREE.SRGBColorSpace;
  const street=new THREE.Mesh(new THREE.PlaneGeometry(8,5), new THREE.MeshBasicMaterial({map:tex}));
  street.position.set(W/2 + F_SMYG + 1.0, 1.8, 0);     // 1 m utanför nischen
  street.rotation.y = -Math.PI/2;
  scene.add(street);
});

/* ======= Skydome (ljus blå himmel med moln) ======= */
function skyTexture(){
  const S=1024, c=document.createElement('canvas'); c.width=c.height=S;
  const g=c.getContext('2d');
  const grd=g.createLinearGradient(0,0,0,S);
  grd.addColorStop(0,'#bfe6ff'); grd.addColorStop(1,'#e6f5ff');
  g.fillStyle=grd; g.fillRect(0,0,S,S);
  g.globalAlpha=0.08; g.fillStyle='#fff';
  for(let i=0;i<120;i++){
    const x=Math.random()*S, y=Math.random()*S*0.7, r=20+Math.random()*60;
    g.beginPath(); g.ellipse(x,y,r*1.8,r,0,0,Math.PI*2); g.fill();
  }
  const t=new THREE.CanvasTexture(c); t.colorSpace=THREE.SRGBColorSpace; return t;
}
const sky=new THREE.Mesh(new THREE.SphereGeometry(60,48,32), new THREE.MeshBasicMaterial({map:skyTexture(), side:THREE.BackSide}));
sky.position.set(0,H+10,-D/2);
scene.add(sky);

/* ======= Egna kamerakontroller (drag + scroll + touch) ======= */
let isDown=false, lastX=0, lastY=0, radius=2.0, theta=0, phi=Math.PI/2.2;
const rMin=1.0, rMax=6.0;
function updateCam(){
  const eps=0.001; phi=Math.max(eps,Math.min(Math.PI-eps,phi));
  radius=Math.max(rMin,Math.min(rMax,radius));
  const x=lookTarget.x + radius*Math.sin(phi)*Math.sin(theta);
  const y=lookTarget.y + radius*Math.cos(phi);
  const z=lookTarget.z + radius*Math.sin(phi)*Math.cos(theta);
  camera.position.set(x,y,z); camera.lookAt(lookTarget);
}
renderer.domElement.addEventListener('pointerdown',e=>{isDown=true;lastX=e.clientX;lastY=e.clientY;});
window.addEventListener('pointerup',()=>{isDown=false;});
window.addEventListener('pointermove',e=>{
  if(!isDown) return; const dx=e.clientX-lastX, dy=e.clientY-lastY; lastX=e.clientX; lastY=e.clientY;
  const ROT=0.005; theta-=dx*ROT; phi-=dy*ROT; updateCam();
},{passive:true});
renderer.domElement.addEventListener('wheel',e=>{
  const ZOOM=0.0015; radius += e.deltaY*ZOOM*(radius*0.8+0.2); updateCam();
},{passive:true});
// touch
let lastDist=null;
renderer.domElement.addEventListener('touchstart',e=>{
  if(e.touches.length===1){lastX=e.touches[0].clientX;lastY=e.touches[0].clientY;}
  if(e.touches.length===2){
    const dx=e.touches[0].clientX-e.touches[1].clientX, dy=e.touches[0].clientY-e.touches[1].clientY;
    lastDist=Math.hypot(dx,dy);
  }
},{passive:true});
renderer.domElement.addEventListener('touchmove',e=>{
  if(e.touches.length===1){
    const t=e.touches[0], dx=t.clientX-lastX, dy=t.clientY-lastY; lastX=t.clientX; lastY=t.clientY;
    const ROT=0.005; theta-=dx*ROT; phi-=dy*ROT; updateCam();
  } else if(e.touches.length===2){
    const dx=e.touches[0].clientX-e.touches[1].clientX, dy=e.touches[0].clientY-e.touches[1].clientY;
    const dist=Math.hypot(dx,dy);
    if(lastDist!=null){ const ZOOM=0.003; radius -= (dist-lastDist)*ZOOM; updateCam(); }
    lastDist=dist;
  }
},{passive:true});
renderer.domElement.addEventListener('touchend',()=>{lastDist=null;},{passive:true});
updateCam();

/* ======= Render & resize ======= */
function loop(){ requestAnimationFrame(loop); renderer.render(scene,camera); }
loop();
addEventListener('resize',()=>{
  camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
