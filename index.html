<!doctype html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D-rummet – egna kontroller</title>
  <style>
    html,body{height:100%;margin:0;background:#111}
    canvas{display:block;width:100vw;height:100vh}
  </style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script>
/* --------- Scen & rum --------- */
const W=4, D=4.1, H=3;

const scene = new THREE.Scene();
scene.background = new THREE.Color(0xdddddd);

const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 100);
const target = new THREE.Vector3(0, 1.5, -1.5); // tittpunkt
camera.position.set(0, 1.5, 1.8);
camera.lookAt(target);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

// Ljus
scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1.1));
const dir = new THREE.DirectionalLight(0xffffff, 0.6); dir.position.set(3,5,2); scene.add(dir);

// Material
const matWall  = new THREE.MeshStandardMaterial({color:0xffffff, roughness:0.95, side:THREE.BackSide});
const matFloor = new THREE.MeshStandardMaterial({color:0x111111, roughness:1});
const matCeil  = new THREE.MeshStandardMaterial({color:0xffffff, roughness:0.95});

// Golv & tak
const floor = new THREE.Mesh(new THREE.PlaneGeometry(W, D), matFloor);
floor.rotation.x = -Math.PI/2; floor.position.set(0,0,-D/2); scene.add(floor);
const ceil  = new THREE.Mesh(new THREE.PlaneGeometry(W, D), matCeil);
ceil.rotation.x  =  Math.PI/2; ceil.position.set(0,H,-D/2); scene.add(ceil);

// Väggar (framvägg utelämnas)
const back  = new THREE.Mesh(new THREE.PlaneGeometry(W, H), matWall);
back.position.set(0, H/2, -D); scene.add(back);
const leftW = new THREE.Mesh(new THREE.PlaneGeometry(D, H), matWall);
leftW.rotation.y =  Math.PI/2; leftW.position.set(-W/2, H/2, -D/2); scene.add(leftW);
const rightW= new THREE.Mesh(new THREE.PlaneGeometry(D, H), matWall);
rightW.rotation.y = -Math.PI/2; rightW.position.set( W/2, H/2, -D/2); scene.add(rightW);

// Testkub
const box = new THREE.Mesh(new THREE.BoxGeometry(0.5,0.5,0.5),
  new THREE.MeshStandardMaterial({color:0xff3355}));
box.position.set(0,0.25,-D/2); scene.add(box);

/* --------- Egna kamerakontroller (drag + scroll) --------- */
let isDown=false, lastX=0, lastY=0;
let radius = 2.0;                 // avstånd till target
let theta  = 0;                    // horisontell vinkel
let phi    = Math.PI/2.2;          // vertikal vinkel (0..PI)
const rMin=1.0, rMax=6.0;

function updateCam(){
  // begränsa phi så vi inte flippar över
  const eps = 0.001;
  phi = Math.max(eps, Math.min(Math.PI - eps, phi));
  radius = Math.max(rMin, Math.min(rMax, radius));
  const x = target.x + radius * Math.sin(phi) * Math.sin(theta);
  const y = target.y + radius * Math.cos(phi);
  const z = target.z + radius * Math.sin(phi) * Math.cos(theta);
  camera.position.set(x,y,z);
  camera.lookAt(target);
}

renderer.domElement.addEventListener('pointerdown', (e)=>{
  isDown=true; lastX=e.clientX; lastY=e.clientY;
});
window.addEventListener('pointerup', ()=>{ isDown=false; });
window.addEventListener('pointermove', (e)=>{
  if(!isDown) return;
  const dx = e.clientX - lastX;
  const dy = e.clientY - lastY;
  lastX = e.clientX; lastY = e.clientY;
  const ROT_SENS = 0.005;   // kännslighet rotation
  theta -= dx * ROT_SENS;
  phi   -= dy * ROT_SENS;
  updateCam();
}, {passive:true});

renderer.domElement.addEventListener('wheel', (e)=>{
  const ZOOM_SENS = 0.0015;
  radius += e.deltaY * ZOOM_SENS * (radius*0.8 + 0.2);
  updateCam();
}, {passive:true});

// Touch (enkel: en-finger rotera, två-finger zoom)
let lastDist=null;
renderer.domElement.addEventListener('touchstart', (e)=>{
  if(e.touches.length===1){ lastX=e.touches[0].clientX; lastY=e.touches[0].clientY; }
  if(e.touches.length===2){
    const dx=e.touches[0].clientX-e.touches[1].clientX;
    const dy=e.touches[0].clientY-e.touches[1].clientY;
    lastDist=Math.hypot(dx,dy);
  }
},{passive:true});
renderer.domElement.addEventListener('touchmove', (e)=>{
  if(e.touches.length===1){
    const t=e.touches[0];
    const dx=t.clientX-lastX, dy=t.clientY-lastY;
    lastX=t.clientX; lastY=t.clientY;
    const ROT_SENS=0.005; theta-=dx*ROT_SENS; phi-=dy*ROT_SENS; updateCam();
  } else if(e.touches.length===2){
    const dx=e.touches[0].clientX-e.touches[1].clientX;
    const dy=e.touches[0].clientY-e.touches[1].clientY;
    const dist=Math.hypot(dx,dy);
    if(lastDist!=null){
      const ZOOM_SENS=0.003;
      radius -= (dist-lastDist)*ZOOM_SENS;
      updateCam();
    }
    lastDist=dist;
  }
},{passive:true});
renderer.domElement.addEventListener('touchend', ()=>{ lastDist=null; }, {passive:true});

// Init
updateCam();

/* --------- Render-loop --------- */
function loop(){
  requestAnimationFrame(loop);
  box.rotation.y += 0.01;
  renderer.render(scene,camera);
}
loop();

// Resize
addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
